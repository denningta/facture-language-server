/******************************************************************************
 * This file was generated by langium-cli 0.4.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, isAstNode, TypeMetaData } from 'langium';

export type AbstractMarkdownElement = Heading1 | PlainText;

export const AbstractMarkdownElement = 'AbstractMarkdownElement';

export function isAbstractMarkdownElement(item: unknown): item is AbstractMarkdownElement {
    return reflection.isInstance(item, AbstractMarkdownElement);
}

export type AbstractMarkdownInlineElement = Bold;

export const AbstractMarkdownInlineElement = 'AbstractMarkdownInlineElement';

export function isAbstractMarkdownInlineElement(item: unknown): item is AbstractMarkdownInlineElement {
    return reflection.isInstance(item, AbstractMarkdownInlineElement);
}

export type DocumentElement = Procedure | Section;

export const DocumentElement = 'DocumentElement';

export function isDocumentElement(item: unknown): item is DocumentElement {
    return reflection.isInstance(item, DocumentElement);
}

export type ProcedureElement = Step;

export const ProcedureElement = 'ProcedureElement';

export function isProcedureElement(item: unknown): item is ProcedureElement {
    return reflection.isInstance(item, ProcedureElement);
}

export type SectionElement = Markdown | Procedure | Section | Step;

export const SectionElement = 'SectionElement';

export function isSectionElement(item: unknown): item is SectionElement {
    return reflection.isInstance(item, SectionElement);
}

export type StepElement = Step;

export const StepElement = 'StepElement';

export function isStepElement(item: unknown): item is StepElement {
    return reflection.isInstance(item, StepElement);
}

export type Text = string;

export interface Bold extends AstNode {
    value: Array<Text>
}

export const Bold = 'Bold';

export function isBold(item: unknown): item is Bold {
    return reflection.isInstance(item, Bold);
}

export interface Heading1 extends AstNode {
    readonly $container: Markdown;
    text: Text
}

export const Heading1 = 'Heading1';

export function isHeading1(item: unknown): item is Heading1 {
    return reflection.isInstance(item, Heading1);
}

export interface Markdown extends AstNode {
    readonly $container: Model | Procedure | Section | Step;
    content: Array<AbstractMarkdownElement>
}

export const Markdown = 'Markdown';

export function isMarkdown(item: unknown): item is Markdown {
    return reflection.isInstance(item, Markdown);
}

export interface Model extends AstNode {
    elements: Array<DocumentElement>
    specification: Specification
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface PlainText extends AstNode {
    readonly $container: Markdown;
    text: Array<Text>
}

export const PlainText = 'PlainText';

export function isPlainText(item: unknown): item is PlainText {
    return reflection.isInstance(item, PlainText);
}

export interface Procedure extends AstNode {
    readonly $container: Model | Procedure | Section | Step;
    content: Array<ProcedureElement>
    procedureNumber: number
    procedureTitle: string
}

export const Procedure = 'Procedure';

export function isProcedure(item: unknown): item is Procedure {
    return reflection.isInstance(item, Procedure);
}

export interface Section extends AstNode {
    readonly $container: Model | Procedure | Section | Step;
    elements: Array<SectionElement>
    sectionID: string
    sectionNumber: number
    sectionTitle?: string
}

export const Section = 'Section';

export function isSection(item: unknown): item is Section {
    return reflection.isInstance(item, Section);
}

export interface Specification extends AstNode {
    readonly $container: Model;
    spec: string
    title: string
}

export const Specification = 'Specification';

export function isSpecification(item: unknown): item is Specification {
    return reflection.isInstance(item, Specification);
}

export interface Step extends AstNode {
    readonly $container: Model | Procedure | Section | Step;
    content: Array<StepElement>
    stepNumber: number
    stepTitle: string
}

export const Step = 'Step';

export function isStep(item: unknown): item is Step {
    return reflection.isInstance(item, Step);
}

export type FactureAstType = 'AbstractMarkdownElement' | 'AbstractMarkdownInlineElement' | 'Bold' | 'DocumentElement' | 'Heading1' | 'Markdown' | 'Model' | 'PlainText' | 'Procedure' | 'ProcedureElement' | 'Section' | 'SectionElement' | 'Specification' | 'Step' | 'StepElement';

export type FactureAstReference = never;

export class FactureAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['AbstractMarkdownElement', 'AbstractMarkdownInlineElement', 'Bold', 'DocumentElement', 'Heading1', 'Markdown', 'Model', 'PlainText', 'Procedure', 'ProcedureElement', 'Section', 'SectionElement', 'Specification', 'Step', 'StepElement'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case Bold: {
                return this.isSubtype(AbstractMarkdownInlineElement, supertype);
            }
            case Heading1:
            case PlainText: {
                return this.isSubtype(AbstractMarkdownElement, supertype);
            }
            case Markdown: {
                return this.isSubtype(SectionElement, supertype);
            }
            case Procedure:
            case Section: {
                return this.isSubtype(DocumentElement, supertype) || this.isSubtype(SectionElement, supertype);
            }
            case Step: {
                return this.isSubtype(SectionElement, supertype) || this.isSubtype(ProcedureElement, supertype) || this.isSubtype(StepElement, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: FactureAstReference): string {
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Bold': {
                return {
                    name: 'Bold',
                    mandatory: [
                        { name: 'value', type: 'array' }
                    ]
                };
            }
            case 'Markdown': {
                return {
                    name: 'Markdown',
                    mandatory: [
                        { name: 'content', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'PlainText': {
                return {
                    name: 'PlainText',
                    mandatory: [
                        { name: 'text', type: 'array' }
                    ]
                };
            }
            case 'Procedure': {
                return {
                    name: 'Procedure',
                    mandatory: [
                        { name: 'content', type: 'array' }
                    ]
                };
            }
            case 'Section': {
                return {
                    name: 'Section',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'Step': {
                return {
                    name: 'Step',
                    mandatory: [
                        { name: 'content', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new FactureAstReflection();
